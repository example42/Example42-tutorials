# Puppet Language

A **Declarative** Domain Specific Language (DSL)

Defines **STATES** (Not procedures)

Puppet code stays in **manifests** (files .pp)

Code contains **resources** that affects elements of the system (file, package, service ...)

Resources are often grouped in **classes** which are generally organized in **modules**

**Variables** may be defined nodes and can be Facts (generated from the node) or User defined

On the Master are defined the resources or classes to include on the **nodes** (clients)

All the resources to apply on a node are defined in the **catalog**, generated by the Master


# Resource Types (Types)

Resources are single **units of configuration** composed by:

A **type** (package, service, file, user, mount, exec ...)

A **title** (how is called and referred)

One or more **arguments**

    type { 'title':
      argument  => value,
      other_arg => value,
    }

Example for a **file** resource type:

    file { 'motd':
      path    => '/etc/motd',
      content => 'Tomorrow is another day',
    }

Complete [Type Reference Online](http://docs.puppetlabs.com/references/3.0.0/type.html) or at the command line

    puppet describe file

Give a glance to Puppet code for the list of **native** resource types:

    ls $(facter rubysitedir)/puppet/type


# Simple samples of resources

Installation of OpenSSH package

    package { 'openssh':
      ensure => present,
    }

Creation of /etc/motd file

    file { 'motd':
      path => '/etc/motd',
    }

Start of httpd service

    service { 'httpd':
      ensure => running,
      enable => true,
    }


# More Complex examples of resources

Installation of Apache package with the correct name for different OS

    package { 'apache':
      ensure => present,
      name   => $::operatingsystem ? {
        /(?i:Ubuntu|Debian|Mint)/ => 'apache2',
        default                   => 'httpd',
      }
    }

Management of nginx service with parameters defined in module's variables

    service { 'nginx':
      ensure     => $::nginx::manage_service_ensure,
      name       => $::nginx::service,
      enable     => $::nginx::manage_service_enable,
    }

Creation of nginx.conf with content retrived from different sources (first found is served)

    file { 'nginx.conf':
      ensure  => present,
      path    => '/etc/nginx/nginx.conf',
      source  => [
          "puppet:///modules/site/nginx.conf--${::fqdn}",
          "puppet:///modules/site/nginx.conf-${role}",
          "puppet:///modules/site/nginx.conf" ],
    }


# Resource Abstraction Layer

Resources are abstracted from the underlying OS

Resource Types have different providers for different OS

Package type is known for the great number of providers

     ls $(facter rubysitedir)/puppet/provider/package

Use **puppet resource** to interrogate the RAL:

    puppet resource user

    puppet resource user root

    puppet resource package

    puppet resource service

Or to directly modify resources:

    puppet resource service httpd ensure=running enable=true


# Classes

Classes are **containers** of different resources. Since Puppet 2.6 they can have parameters

Example of a class **definition**:

    class mysql {
      package { 'mysql-server':
        ensure => present,
      }
      service { 'mysql':
        ensure    => running,
      }
      [...]
    }

Usage (declaration) of "old style" classes (without parameters):
Even if a class is a singleton, you can include it multiple times: it's applied only once.

    include mysql

Usage (declaration) of a parametrized classes
You can declare a parametrized class only once for a node

    class { 'mysql':
      required_param => 'my_value',
      optional_param => 'dont_like_defaults',
    }


# Defines

Also called: **Defined resource types** or **defined types**

Similar to parametrized classes but can be used multiple times, with different parameters

**Definition** example:

    define apache::virtualhost (
      $template = 'apache/virtualhost.conf.erb' ,
      [...] ) {

      file { "ApacheVirtualHost_${name}":
        ensure  => $ensure,
        content => template("${template}"),
      }
    }

Usage example (**declaration**):

    apache::virtualhost { 'www.example42.com':
      template => 'site/apache/www.example42.com-erb'
    }



# Variables

You need them to provide different configurations for different kind of servers

Can be provided by client nodes as **facts**

**Facter** runs on clients and collects **facts** that the server can use as variables

    al$ facter

    architecture => x86_64
    fqdn => Macante.example42.com
    hostname => Macante
    interfaces => lo0,eth0
    ipaddress => 10.42.42.98
    ipaddress_eth0 => 10.42.42.98
    kernel => Linux
    macaddress => 20:c9:d0:44:61:57
    macaddress_eth0 => 20:c9:d0:44:61:57
    memorytotal => 16.00 GB
    netmask => 255.255.255.0
    operatingsystem => Centos
    operatingsystemrelease => 6.3
    osfamily => RedHat
    virtual => physical

Or can be **defined by users**.


# User Variables

You can define custom variables in different ways:

#### In Puppet **manifests**:

        $role = 'mail'

        $package = $::operatingsystem ? {
          /(?i:Ubuntu|Debian|Mint)/ => 'apache2',
          default                   => 'httpd',
        }

#### In an **External Node Classifier** (ENC)

Commonly used ENC are Puppet DashBoard, the Foreman, Puppet Enterprise.

#### In an **Hiera** backend

        $syslog_server = hiera(syslog_server)


# Nodes - Default classification

A node is identified by the PuppetMaster by its **hostname** or **certname**

By default you can decide what classes to assign to a each server with the node statement

## In the site manifest

Using Puppet language ( Starting from ```/etc/puppet/manifests/site.pp``` ) you can define nodes with a syntax like:

    node 'web01' {
      include apache
    }

A node can inherit another node and include all the classes and variables defined for it:

    node base {
      include openssh
      include ntp
    }

    node 'web01' inherits base {
      include apache
    }

(Note: Using nodes' inheritance to assign classes is now deprecated)

# Nodes - Alternative approaches

Classes can be assigned to nodes in alternative ways:

## On an External Node Classifier (ENC)
Puppet can query an external source to retrieve the classes and the variables to assign to a node. This source is called External Node Classifier and can be anything that when interrogated via a script with the clients' certname returns a yaml file with the list of classes and parameters.

Common ENC are Puppet DashBoard, Foreman and Puppet Enterprise (where the functionality of ENC is enabled by default).

To enable the usage of an ENC set these parameters in puppet.conf

    external_nodes = /etc/puppet/node.rb # Script that queries the ENC
    node_terminus = exec                 # Enable the usage of the script

## With hiera_include

Hiera provides a **hiera_include** function that allows the inclusion of classes as defined on Hiera. This is an emerging approach that is particularly useful when there's massive usage of Hiera as backend for Puppet data.

In ```/etc/puppet/manifests/site.pp``` just place:

    hiera_include('classes')

and place, as an array, the classes to include in you Hiera data source under the key 'classes'.

# The Catalog

The **catalog** is the complete list of resources, and their relationships, that the Puppet Master compiles for the client.

It's the result of all the puppet code and logic that we define for a given node in our manifests and is applied on the client after it has been compiled and received from the master.

The client uses the RAL (Resource Abstraction Layer) to execute the actual system's commands that convert abstract resources like

    package { 'openssh': }

to their actual fullfillment on the system (```apt-get install openssh``` , ```yum install openssh``` ...).

The catalog is saved by the client in ```/var/lib/puppet/client_yaml/catalog/$certname.yaml```
